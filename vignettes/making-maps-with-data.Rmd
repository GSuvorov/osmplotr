---
title: "Making Maps with Data"
author: "Mark Padgham"
date: "`r Sys.Date()`"
#output: rmarkdown::pdf_document
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Making Maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

**Fix TODOs!**

This vignette extends from the vignette 'making-maps' to demonstrate how
user-defined data layers may be used to further customise the appearance of maps
produced with `osmplotr`. Categorical data may be plotted by highlighting
categorically different regions with different colours using `add_osm_groups`,
while continuous data may be plotted with `add_osm_surface`.


```{r load, message=FALSE}
library (osmplotr)
library (maptools) # Needed for this vignette
```
```{r, echo=FALSE, message=FALSE}
setwd ('../..')
devtools::load_all ('osmplotr')
setwd ('./osmplotr/vignettes')
```
As in the first vignette, maps produced in this vignette contain data for a
small portion of central London, U.K.
```{r}
bbox <- get_bbox (c(-0.13,51.51,-0.11,51.52))
```
```{r, echo=FALSE}
mapwd <- 500
mapht <- mapwd * diff (bbox [2,]) / diff (bbox [1,])
```

```{r, echo=FALSE, message=FALSE}
indx <- which (!london$dat_BR$id %in% london$dat_BNR$id)
dat_B <- maptools::spRbind (london$dat_BR [indx,], london$dat_BNR)
indx <- which (!london$dat_H$id %in% london$dat_HP$id)
dat_H <- maptools::spRbind (london$dat_H [indx,], london$dat_HP)
dat_T <- london$dat_T
dat_HP <- london$dat_HP
```

--------------------
## Contents

[1 Categorical data](#1 cat-data)

[&nbsp;&nbsp;&nbsp;&nbsp;1.1 Hulls around groups](#1.1 hulls)

[&nbsp;&nbsp;&nbsp;&nbsp;1.2 Inclusive, exclusive and bisected polygons](#1.2 polygons)

[&nbsp;&nbsp;&nbsp;&nbsp;1.3 Adjusting colours](#1.3 adjust-colours)

[&nbsp;&nbsp;&nbsp;&nbsp;1.4 Dark-on-Light Highlights](#1.4 dark-on-light)

[&nbsp;&nbsp;&nbsp;&nbsp;1.5 Visualising clustering data](#1.5 clusters)

[&nbsp;&nbsp;&nbsp;&nbsp;1.6 The Colour Matrix](#1.6 colmat)

[&nbsp;&nbsp;&nbsp;&nbsp;1.7 Bounding areas within named highways](#1.7 highways)

--------------------

## <a name="1 cat-data"></a>1. Categorical data: `add_osm_groups`

The function `add_osm_groups` enables spatially-defined groups to be plotted in
different colours.  The two primary arguments are `obj`, which defines the OSM
structure to be used for plotting the regions, and `groups` which is a list of
SpatialPoints objects defining the desired regions. An example of an `obj` is
the SpatialPolygonsDataFrame of buildings downloaded in the first vingette with
the following line
```{r, eval=FALSE}
dat_B <- extract_osm_objects (key='building', bbox=bbox)
```

The most direct way to define `groups` is through specifying coordinates of
boundary points:
```{r map1, eval=FALSE}
pts <- sp::SpatialPoints (cbind (c (-0.115, -0.125, -0.125, -0.115),
                             c (51.513, 51.513, 51.517, 51.517)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=pts, cols='orange', bg='gray40')
print (map)
```
```{r map1-print, echo=FALSE}
pts <- sp::SpatialPoints (cbind (c (-0.115, -0.125, -0.125, -0.115),
                             c (51.513, 51.513, 51.517, 51.517)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=pts, cols='orange', bg='gray40')
png (height=mapht, width=mapwd, file='map_b1.png')
print (map)
graphics.off ()
```
![map1](map_b1.png)

Multiple groups can be defined by passing a list of `SpatialPoints` objects to
the `groups` argument of `add_osm_groups`, and specifying corresponding colours.
```{r map2, eval=FALSE}
pts2 <- sp::SpatialPoints (cbind (c (-0.111, -0.1145, -0.1145, -0.111),
                             c (51.517, 51.517, 51.519, 51.519)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), 
                       cols=c ('orange', 'tomato'), bg='gray40')
print (map)
```
```{r map2-print, echo=FALSE}
pts2 <- sp::SpatialPoints (cbind (c (-0.111, -0.1145, -0.1145, -0.111),
                             c (51.517, 51.517, 51.519, 51.519)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), 
                       cols=c ('orange', 'tomato'), bg='gray40')

png (height=mapht, width=mapwd, file='map_b2.png')
print (map)
graphics.off ()
```
![map2](map_b2.png)

The `bg` argument specifies the colour of any objects lying outside the
boundaries of the specified groups. If this argument is not given, then all
objects are assigned to the nearest group, so that the groups fill the entire
map.
```{r map3, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), 
                       cols=c ('orange', 'tomato'))
print (map)
```
```{r map3-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), 
                       cols=c ('orange', 'tomato'))
png (height=mapht, width=mapwd, file='map_b3.png')
print (map)
graphics.off ()
```
![map3](map_b3.png)

## <a name="1.1 hulls"></a>1.1 Hulls around groups

`add_osm_groups` includes the argument `make_hull` which specifies whether
convex hulls should be fitted around the points defining the provided `groups`,
or whether the `groups` already define their own boundaries (the default
behaviour). If a point is added internal to the four points defining the first
of the above groups, then the group boundary will connect to that point and
create a concave shape.

```{r map5, eval=FALSE}
pts <- sp::SpatialPoints (rbind (coordinates (pts), c (-0.12, 51.515)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=pts, cols='orange', bg='gray40')
print (map)
```
```{r map5-print, echo=FALSE}
pts <- sp::SpatialPoints (rbind (coordinates (pts), c (-0.12, 51.515)))
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=pts, cols='orange', bg='gray40')
png (height=mapht, width=mapwd, file='map_b5.png')
print (map)
graphics.off ()
```
![map5](map_b5.png)

The previous points started in the south-east and ended in the north-east, and
thus the concave boundary extends in between the two easterly points. Setting
`make_hull=TRUE` defines groups by the convex hulls surrounding them, which in
this case would revert this map to the initial map with the group defined by a
regular, convex perimeter.

## <a name="1.2 polygons"></a>1.2 Inclusive, exclusive, and bisected polygons

The highlighted regions of the previous maps are irregular because the default
behaviour of `add_osm_groups` is to include within a group only those OSM
objects which lie entirely within a group boundary.  `add_osm_groups` has a
`boundary` argument which defines whether objects should be assigned to groups
inclusively (`boundary>0`) or exclusively (`boundary<0`), or whether they should
be precisely bisected by a group boundary (`boundary=0`).  The previous maps
illustrate the default option (`boundary=-1`), while the two other options
produce the following maps. 

```{r map6, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=1)
print (map)
```
```{r map6-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=1)
png (height=mapht, width=mapwd, file='map_b6.png')
print (map)
graphics.off ()
```
![map6](map_b6.png)

The inclusive option (`boundary>0`) includes all objects which have any points
lying within a boundary, meaning more objects are included resulting in larger
regions than the previous default exclusive option. Precisely
bisecting boundaries produces the following map.

```{r map7, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
print (map)
```
```{r map7-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
png (height=mapht, width=mapwd, file='map_b7.png')
print (map)
graphics.off ()
```
![map7](map_b7.png)


The ability to combine different kinds of boundaries is particularly useful when
highlighting areas which partially contain large polygons such as parks. The
parks within the following maps were downloaded with
```{r, eval=FALSE}
dat_P <- extract_osm_objects (key='park', bbox=bbox)
```
(Noting that, as described in the 'making-maps' vignette, both
`extract_osm_objects` and `make_osm_map` convert several common keys to
appropriate `key-value` pairs, so
```{r}
osm_structures (structure='park')
```
reveals that this `key` is actually converted to `key='leisure'` and
`value='park'`.)
```{r, echo=FALSE}
dat_P <- london$dat_P
```
Plotting buildings inclusively within each group and parks bisected by the
group boundaries produces the following map:
```{r map8, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
col_park_in <- rgb (50, 255, 50, maxColorValue=255)
col_park_out <- rgb (50, 155, 50, maxColorValue=255)
map <- add_osm_groups (map, dat_P, groups=list (pts, pts2), 
                       cols=rep (col_park_in, 2), bg=col_park_out, boundary=0)
print (map)
```
```{r map8-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
col_park_in <- rgb (50, 255, 50, maxColorValue=255)
col_park_out <- rgb (50, 155, 50, maxColorValue=255)
map <- add_osm_groups (map, dat_P, groups=list (pts, pts2), 
                       cols=rep (col_park_in, 2), bg=col_park_out, boundary=0)
png (height=mapht, width=mapwd, file='map_b8.png')
print (map)
graphics.off ()
```
![map8](map_b8.png)

Bisection divides single polygons to form one polygon of points lying within a
given boundary and one polygon of points lying outside the boundary. The two
resultant polygons are often separated by visible gaps between locations at
which they are defined.  Because the layers of a plot are progressively
overlaid, such gaps can be avoided by initially plotting underlying layers using
`add_osm_objects` prior to grouping objects:

```{r map9, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_objects (map, dat_P, col=col_park_out)
map <- add_osm_groups (map, dat_P, groups=list (pts, pts2), 
                       cols=rep (col_park_in, 2), bg=col_park_out, boundary=0)
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
print (map)
```
```{r map9-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_objects (map, dat_P, col=col_park_out)
map <- add_osm_groups (map, dat_P, groups=list (pts, pts2), 
                       cols=rep (col_park_in, 2), bg=col_park_out, boundary=0)
map <- add_osm_groups (map, dat_B, groups=list (pts, pts2), make_hull=TRUE,
                       cols=c ('orange', 'tomato'), bg='gray40', boundary=0)
png (height=mapht, width=mapwd, file='map_b9.png')
print (map)
graphics.off ()
```
![map9](map_b9.png)

Bisections with `boundary=0` will only be as accurate as the underlying OSM
data. This example was chosen to highlight how inaccurate bisection may be if
actual OSM points do not lie near to a desired bisection line. The larger a
map, the less visually evident are likely to be any such inaccuracies. Finally,
note that the plot order was changed to allow the building within the park to be
overlaid upon the grass surfaces. Plot order, whether controlled manually or
with `make_osm_map`, may often have to be tweaked to appropriately visualise all
objects.

The `boundary` argument has no effect if `bg` is not given, because in this case
all objects will be assigned to a group and there will be no boundaries between
groups and other, non-grouped objects.

## <a name="1.3 adjust-colours"></a>1.3 Adjusting colours with `adjust_colours`

The `adjust_colours` function allows different groups to be highlighted with
slightly different colours for different kinds of OSM objects. For example, the
following code adds highways to the above map in slightly darkened versions of
the highlight colours (using `boundary=1`, so any highways with any points lying
within the bounding box are included in the groups):
```{r map10, eval=FALSE}
dat_HP <- extract_osm_objects (key="highway", value="primary", bbox=bbox)
dat_H <- extract_osm_objects (key="highway", value="!primary", bbox=bbox)
# darken colours by aboud 20%
cols_adj <- adjust_colours (c ('orange', 'tomato'), adj=-0.2)
map <- add_osm_groups (map, dat_HP, groups=list (pts, pts2), make_hull=TRUE,
                       cols=cols_adj, bg=adjust_colours ('gray40', adj=-0.4), 
                       boundary=1, size=2)
map <- add_osm_groups (map, dat_H, groups=list (pts, pts2), make_hull=TRUE,
                       cols=cols_adj, bg=adjust_colours ('gray40', adj=-0.2), 
                       boundary=1, size=1)
print (map)
```
```{r map10-print, echo=FALSE}
dat_H <- london$dat_H
dat_HP <- london$dat_HP
cols_adj <- adjust_colours (c ('orange', 'tomato'), adj=-0.2)
map <- add_osm_groups (map, dat_HP, groups=list (pts, pts2), make_hull=TRUE,
                       cols=cols_adj, bg=adjust_colours ('gray40', adj=-0.4), 
                       boundary=1, size=2)
map <- add_osm_groups (map, dat_H, groups=list (pts, pts2), make_hull=TRUE,
                       cols=cols_adj, bg=adjust_colours ('gray40', adj=-0.2), 
                       boundary=1, size=1)
png (height=mapht, width=mapwd, file='map_b10.png')
print (map)
graphics.off ()
```
![map10](map_b10.png)

(And of course `adjust_colours ('gray40', adj=-0.2)` is nothing other than
'gray32', and `adj=-0.4` gives 'gray24'.)

## <a name="1.4 dark-on-light"></a>1.4 Dark-on-Light Highlights 

A particularly effective way to highlight single regions within a map is through
using dark colours upon otherwise light coloured maps.
```{r map11, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=pts, cols='gray40', bg='gray85',
                   boundary=1)
map <- add_osm_groups (map, dat_H, groups=pts, cols='gray20', bg='gray70',
                   boundary=0)
map <- add_osm_groups (map, dat_HP, groups=pts, cols='gray10', bg='white',
                   boundary=0, size=1)
print (map)
```
```{r map11-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=pts, cols='gray40', bg='gray85',
                   boundary=1)
map <- add_osm_groups (map, dat_H, groups=pts, cols='gray20', bg='gray70',
                   boundary=0)
map <- add_osm_groups (map, dat_HP, groups=pts, cols='gray10', bg='white',
                   boundary=0, size=1)
png (height=mapht, width=mapwd, file='map_b11.png')
print (map)
graphics.off ()
```
![map11](map_b11.png)


## <a name="1.5 clusters"></a>1.5 Visualising clustering data

One of the most likely uses of `add_osm_groups` is to visualise statistical
clusters. Clustering algorithms will generally produce membership lists which
may be mapped onto spatial locations. Each cluster can be converted to a data
frame of `SpatialPoints`, and the `groups` specified as a list, each item of
which represents one cluster.  A general approach is illustrated here with
`groups` defined by single, randomly generated points.
```{r}
ngroups <- 12
x <- bbox [1,1] + runif (ngroups) * diff (bbox [1,])
y <- bbox [2,1] + runif (ngroups) * diff (bbox [2,])
groups <- cbind (x, y)
groups <- apply (groups, 1, function (i) 
              sp::SpatialPoints (matrix (i, nrow=1, ncol=2)))
```
Having generated the points, a map of corresponding clusters can be generated by
the following simple code.
```{r map12, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, 
                       cols=rainbow (length (groups)))
print (map)
```
```{r map12-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, 
                       cols=rainbow (length (groups)))
png (height=mapht, width=mapwd, file='map_b12.png')
print (map)
graphics.off ()
```
![map12](map_b12.png)

Although individual groups will generally be defined by collections of multiple
points, this example illustrates that they can also be defined by single points.
In such cases, the `bg` option should of course be absent, so that all remaining
points are allocated to the nearest groups.

This map also illustrates the kind of visual mess that may arise in attempts to
specify colours, particularly because the sequence of colours passed to
`add_osm_groups` will generally not map on to any particular spatial order, so
even if a pleasing colour scheme is submitted, the results may still be less
than desirable. Although it may be possible to devise pleasing schemes for small
numbers of groups, manually defined colour schemes are likely to become
impractical for larger numbers of groups.

```{r map13, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, borderWidth=2,
                       cols=heat.colors (length (groups)))
print (map)
```
```{r map13-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, borderWidth=2,
                       cols=heat.colors (length (groups)))
png (height=mapht, width=mapwd, file='map_b13.png')
print (map)
graphics.off ()
```
![map13](map_b13.png)

Note the submitting any positive values to the additional `borderWidth` argument
causes `add_osm_groups` to drawn convex hull borders around the different
groups. Even this is not sufficient, however, to render the result particularly
visually pleasing or intelligible. To overcome this, `add_osm_groups` includes
an option described in the following section to generate spatially sensible
colour schemes for colouring distinct groups.

## <a name="1.6 colmat"></a>1.6 The Colour Matrix: Colouring Several Regions

An additional argument which may be passed to `add_osm_groups` is `colmat`,
an abbreviation of 'colour matrix'. If set to true (the default is `FALSE`),
group colours are specified by the function `colour_mat`. This function takes
a vector of four or more colours as input, wraps them around the four corners of a
rectangular grid, and spatially interpolates a chromatially regular grid between
these corners. To visual different schemes, it has a `plot` argument:

```{r, fig.width=4}
plot.new ()
cmat <- colour_mat (plot=TRUE)
```

This grid illustrates the default colours, `rainbow (4)`. The two-dimensional
colour field produced by `colour_mat` may also be rotated by a specified number
of degrees using the `rotate` argument.

```{r, fig.width=4}
plot.new ()
cmat <- colour_mat (n=8, rotate=90, plot=TRUE)
```

This example also illustrates that the size of colour matrices may also be
arbitrarily specified (and need not be square if `rotate` is not desired). Using
the `colmat` option in `add_osm_groups` enables the previous maps to be redrawn
like this:
```{r map14, eval=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, borderWidth=2, colmat=TRUE,
                       cols=c('red','green','yellow','blue'), rotate=180)
print (map)
```
```{r map14-print, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray95')
map <- add_osm_groups (map, dat_B, groups=groups, borderWidth=2, colmat=TRUE,
                       cols=c('red','green','yellow','blue'), rotate=180)
png (height=mapht, width=mapwd, file='map_b14.png')
print (map)
graphics.off ()
```
![map14](map_b14.png)

Note both that when `add_osm_groups` is called with `colmat=TRUE`, then `cols`
need only be of length 4, to specify the four corners of the colour matrix, and
also that the `rotate` argument can be submitted to `add_osm_groups` and passed
on to `colour_mat`.


## <a name="1.7 highways"></a>1.7 Bounding areas within named highways

As explained in the first vignette ('making-maps'), the function
`connect_highways` takes a list of OSM highway names and a bounding box, and
returns the boundary of a polygon encircling the named highways. This can be
used to highlight selected regions simply by naming the highways which encircle
them, producing maps which look like this:
```{r}
highways <- c ('Monmouth.St', 'Short.?s.Gardens', 'Endell.St', 'Long.Acre',
               'Upper.Saint.Martin')
highways1 <- connect_highways (highways=highways, bbox=bbox, plot=T)
```
Note the use of the `regex` '?' denoting the previous character as optional.
This is necessary here because there are OSM sections named both "Shorts
Gardens" and "Short's Gardens".

```{r, echo=FALSE}
structures <- c ('amenity', 'grass', 'park', 'natural')
structs <- osm_structures (structures=structures, col_scheme='dark')
col_G <- structs$cols [structs$structure == 'grass']
col_A <- structs$cols [structs$structure == 'amenity']

groups <- list (london$highways1, london$highways2, london$highways3)
bg_B <- 'gray40'
# Then set building colours for the 3 groups, and darken them for highways
cols_B <- c ('red', 'green', 'blue')
cols_H <- adjust_colours (cols_B, -0.2)
bg_H <- 'gray20'
```

```{r map19, echo=FALSE}
map <- plot_osm_basemap (bbox=bbox, bg='gray20')
map <- add_osm_objects (map, london$dat_P, col=col_G)
map <- add_osm_objects (map, london$dat_G, col=col_G)
map <- add_osm_objects (map, london$dat_N, col=col_G)
map <- add_osm_objects (map, london$dat_A, col=col_A)
map <- add_osm_groups (map, london$dat_BNR, groups=groups, boundary=0,
                   bg=bg_B, colmat=FALSE, col=cols_B)
map <- add_osm_groups (map, london$dat_BR, groups=groups, boundary=0,
                   bg=bg_B, colmat=FALSE, col=cols_B)

map <- add_osm_groups (map, london$dat_H, groups=groups, boundary=0,
                   bg=bg_H, colmat=FALSE, col=cols_H)
map <- add_osm_groups (map, london$dat_HP, groups=groups, boundary=0,
                   bg=bg_H, colmat=FALSE, col=cols_H)
```
```{r map19-print, echo=FALSE}
png (height=mapwd, width=mapwd, file='map19.png')
print (map)
graphics.off ()
```
![map19](map19.png)

Note that the lists of highways were obtained using expanding bounding boxes as
described above, and given in the `london` data provided with `osmplotr`. The
following plots thus only include restricted portions of these entire regions,
while the full polygons surrounding the named areas can be seen by repeating the
extraction of data with a larger bounding box:
```{r, eval=FALSE}
bbox <- get_bbox (c(-0.15,51.5,-0.1,51.52)) 
```

### 6.1 The `connect_highways` function

The primary function enabling the delination of groups like the above is
`connect_highways`, an example of which is the orange area above, the boundary
of which was obtained from:
```{r, eval=FALSE}
highways <- c ('Kingsway', 'Holborn', 'Farringdon.St', 'Strand',
               'Fleet.St', 'Aldwych')
highways1 <- connect_highways (highways=highways, bbox=bbox)
```
```{r}
## Warning in connect_highways(ways): Cycle unable to be extended through all
## ways
```
The reason for the warning will be explored further below. In the meantime, note
that,
```{r, echo=FALSE}
highways1 <- london$highways1
```
```{r}
class (highways1)
head (sp::coordinates (highways1))
dim (sp::coordinates (highways1))
```

```{r, eval=FALSE}
highways <- c ('Queen.s.Walk', 'Blackfriars', 'Waterloo', 'The.Cut')
highways2 <- connect_highways (highways=highways, bbox=bbox)
highways <- c ('Regent.St', 'Oxford.St', 'Shaftesbury')
highways3 <- connect_highways (highways=highways, bbox=bbox)
```
Multiple regions may be highlighted simply by passing a list of bounding
polygons (each of class `SpatialPoints`) to `add_osm_groups`. 
```{r, eval=FALSE}
groups <- list (highways1, highways2, highways3)
```
```{r, echo=FALSE}
groups <- list (london$highways1, london$highways2, london$highways3)
```
Highlighted groups are then added as above using `add_osm_groups`. These are
overlaid on top of a basemap. The following maps highlight the selected regions
with both buildings and highways, while the remaining structures are plotted on
the initial basemap with the following lines. (Note that `make_osm_map` returns
`osm_data` with any additional structures not previously present added; in the
following case, these data are not altered.)
```{r map20, eval=TRUE}
structures <- c ('amenity', 'grass', 'park', 'natural')
structs <- osm_structures (structures=structures, col_scheme='dark')
bbox <- get_bbox (c(-0.13,51.5,-0.11,51.52)) # back to smaller bbox
dat <- make_osm_map (bbox=bbox, osm_data=london, structures=structs)
```
```{r, eval=FALSE}
print (dat$map)
```
```{r map20-print, echo=FALSE}
png (height=mapwd, width=mapwd, file='map20.png')
print (map)
graphics.off ()
```
![map20](map20.png)

The desired areas are then highlighted in the following lines using colours from
`RColorBrewer`.  These lines also demonstrate how particular colours may be
lightened or darkened for use as highlights. 
```{r}
cols <- c ('tomato', 'skyblue', 'lawngreen')
cols_dark <- adjust_colours (cols, -0.3)
```
And finally add groups to plot using these colours, resulting in the plot shown
at the start of this section.
```{r map21}
map <- add_osm_groups (map, london$dat_BNR, groups=groups, boundary=0,
                   bg=bg_B, colmat=FALSE, col=cols)
map <- add_osm_groups (map, london$dat_BR, groups=groups, boundary=0,
                   bg=bg_B, colmat=FALSE, col=cols)

map <- add_osm_groups (map, london$dat_H, groups=groups, boundary=0,
                   bg=bg_H, colmat=FALSE, col=cols_dark)
map <- add_osm_groups (map, london$dat_HP, groups=groups, boundary=0,
                   bg=bg_H, colmat=FALSE, col=cols_dark)
```

The extraction of bounding polygons from named highways is not failsafe, as
demonstrated by the above error message. To understand why it may not work, it
is usefull to examine `connect_highways` in more detail, as follows. 
points.

