#' add_osm_suface
#'
#' Adds a colour-coded surface of spatial objects (polygons, lines, or points
#' generated by extract_osm_objects ()) to a graphics object initialised with
#' plot_osm_basemap(). The surface is spatially interpolated between the values
#' given in 'dat', which has to be a matrix or data.frame of 3 colums (x, y, z),
#' where (x,y) are (longitude, latitude), and z are the values to be
#' interpolated. Interpolation uses spatstat::Smoothing.ppp, which applies a
#' Gaussian kernel smoother optimised to the given data, and is effectively
#' non-parametric.
#'
#' @param map A ggplot2 object to which the surface are to be added
#' @param obj an sp SPDF or SLDF (list of polygons, lines, or points) returned by
#' extract_osm_objects ()
#' @param dat A matrix or data frame of 3 columns (x, y, z), where (x, y) are
#' (longitude, latitude), and z are the values to be interpolated
#' @param method Either 'idw' (Inverse Distance Weighting as spatstat::idw;
#' default), otherwise uses 'Gaussian' for kernel smoothing (as
#' spatstat::Smooth.ppp)
#' @param grid_size size of interpolation grid 
#' @param cols Vector of colours for shading z-values (for example,
#' 'terrain.colors (30)')
#' @param bg If specified, OSM objects outside the convex hull surrounding 'dat'
#' are plotted in this colour, otherwise they are included in the interpolation
#' (which will generally be inaccurate for peripheral values)
#' @param size Size argument passed to ggplot2 (polygon, path, point) functions:
#' determines width of lines for (polygon, line), and sizes of points.
#' Respective defaults are (0, 0.5, 0.5).
#' @return modified version of map (a ggplot object) to which surface has been
#' added
#'
#' @note 
#' Spatial smoothing is *interpolative* and so values beyond the bounding
#' polygon of 'dat' will generally be unreliable. Points beyond the bounding
#' polygon are only included in the interpolation if 'bg' is NA or NULL.
#'
#' @export
#'
#' @examples
#' # Make a data frame of volcano data mapped onto map coordinates, and remove
#' # periphery
#' bbox <- get_bbox (c (-0.13, 51.5, -0.11, 51.52))
#' getdat <- function (bbox)
#' {
#'     dims <- dim (volcano)
#'     d1 <- array (seq (dims [1]) - dims[1] / 2, dim=dims)
#'     d2 <- t (array (seq (dims [2]) - dims[2] / 2, dim=rev (dims)))
#'     dv <- sqrt (d1 ^ 2 + d2 ^ 2) # define perhiphery as dv > 40
#' 
#'     x <- seq (bbox [1,1], bbox [1,2], length.out=dims [1])
#'     y <- seq (bbox [2,1], bbox [2,2], length.out=dims [2])
#'     dat <- data.frame (
#'                        x=rep (x, dims [2]),
#'                        y=rep (y, each=dims [1]),
#'                        z=as.numeric (volcano)
#'                        )
#'     dat$z [as.numeric (dv) > 40] <- NA
#'     return (dat)
#' }
#' dat <- getdat (bbox)
#' 
#' # Plotting order is important because each layer overlays the previous
#' map <- plot_osm_basemap (bbox=bbox, bg="gray20")
#' map <- add_osm_objects (map, london$dat_HP, col="gray70", size=1)
#' cols <- heat.colors (30)
#' map <- add_osm_surface (map, london$dat_BNR, dat, cols=cols, bg="gray40")
#' map <- add_osm_surface (map, london$dat_H, dat, 
#'                         cols=adjust_colours (cols, adj=-0.2), bg="black")
#' map <- add_osm_objects (map, london$dat_T, col="green")
#' map <- add_axes (map)
#' map <- add_colourbar (map, cols=heat.colors (100), zlims=range (volcano),
#'                       barwidth=c(0.02), barlength=c(0.6,0.99), vertical=TRUE)
#' print (map)


add_osm_surface <- function (map, obj, dat, method="idw", grid_size=100,
                              cols=heat.colors (30), bg, size)
{
    if (class (obj) == 'SpatialPolygonsDataFrame')
    {
        xy0 <- lapply (slot (obj, 'polygons'), function (x)
                        slot (slot (x, 'Polygons') [[1]], 'coords'))
        xy0 <- structure (xy0, class=c (class (xy0), 'polygons'))
        xy0 <- list2df_with_data (map, xy0, dat, bg, grid_size=grid_size)
        if (missing (bg))
            xy <- xy0
        else
            xy <- xy0 [xy0$inp > 0, ]

        # TODO: Add border to geom_polygon call
        lon <- lat <- id <- z <- NULL # suppress 'no visible binding' error
        aes <- ggplot2::aes (x=lon, y=lat, group=id, fill=z) 
        map <- map + ggplot2::geom_polygon (data=xy, mapping=aes, size=1) +
                        ggplot2::scale_fill_gradientn (colours=cols) 

        if (!missing (bg))
        {
            xy <- xy0 [xy0$inp == 0, ]
            aes <- ggplot2::aes (x=lon, y=lat, group=id) 
            map <- map + ggplot2::geom_polygon (data=xy, mapping=aes, size=0.2,
                                                          fill=bg)
        }
    } else if (class (obj) == 'SpatialLinesDataFrame')
    {
        xy0 <- lapply (slot (obj, 'lines'), function (x)
                        slot (slot (x, 'Lines') [[1]], 'coords'))
        xy0 <- structure (xy0, class=c (class (xy0), 'lines'))
        xy0 <- list2df_with_data (map, xy0, dat, bg, grid_size=grid_size)
        if (missing (bg))
            xy <- xy0
        else
            xy <- xy0 [xy0$inp > 0,]

        aes <- ggplot2::aes (x=lon, y=lat, group=id, colour=z)
        map <- map + ggplot2::geom_path (data=xy, mapping=aes) +
                        ggplot2::scale_colour_gradientn (colours=cols)

        if (!missing (bg))
        {
            xy <- xy0 [xy0$inp == 0, ]
            aes <- ggplot2::aes (x=lon, y=lat, group=id) 
            map <- map + ggplot2::geom_path (data=xy, mapping=aes, size=0.5,
                                                          col=bg)
        }
    } else if (class (obj) == 'SpatialPointsDataFrame')
    {
        xy0 <- sp::coordinates (obj)
        xy0 <- structure (xy0, class=c (class (xy0), 'points'))
        xy <- list2df_with_data (map, xy0, dat, bg, grid_size=grid_size)

        aes <- ggplot2::aes (x=lon, y=lat, group=id, colour=z)
        map <- map + ggplot2::geom_point (data=xy, mapping=aes) +
                        ggplot2::scale_colour_gradientn (colours=cols)
    }

    return (map)
}



#' list2df_with_data
#'
#' Converts a list of spatial objects to a single data frame, and adds a
#' corresponding 'z' column provided by mapping mean object coordinates onto a
#' spatially interpolated version of 'dat'
#'
#' @param map A ggplot2 object (used only to obtain plot limits)
#' @param xy List of coordinates of spatial objects
#' @param dat A data surface (which may be irregular) used to provide the
#' z-values for the resultant data frame.
#' @param bg background colour from 'add_osm_surface()', passed here only to
#' confirm whether it is given or missing
#' @param grid_size Size of interpolation grid as taken from 'add_osm_surface()'
#' @param method Either 'idw' (Inverse Distance Weighting as spatstat::idw;
#' default), otherwise uses 'Gaussian' for kernel smoothing (as
#' spatstat::Smooth.ppp)
#' @return A single data frame of object IDs, coordinates, and z-values
list2df_with_data <- function (map, xy, dat, bg, grid_size=100, method="idw")
{
    indx <- which (!is.na (dat [,3]))
    x <- dat [indx,1]
    y <- dat [indx,2]
    marks <- dat [indx,3]
    xyp <- spatstat::ppp (x, y, xrange=range (x), yrange=range(y), marks=marks)
    if (method == 'idw')
        z <- spatstat::idw (xyp, at="pixels", dimyx=grid_size)$v
    else
        z <- spatstat::Smooth (xyp, at="pixels", dimyx=grid_size, diggle=TRUE)$v

    # Get mean coordinates of each object in xy. 
    # TODO: Colour lines continuously according to the coordinates of each
    # segment?
    if ('polygons' %in% class (xy) | 'lines' %in% class (xy))
        xymn <- do.call (rbind, lapply (xy, colMeans))
    else if ('points' %in% class (xy))
        xymn <- xy
    else
        stop ('xy must be a spatial object')

    # Then remove any objects not in the convex hull of provided data
    indx <- rep (NA, length (xy))
    if (!missing (bg))
    {
        xyh <- spatstat::ppp (x, y, xrange=range (x), yrange=range (y))
        ch <- spatstat::convexhull (xyh)
        bdry <- cbind (ch$bdry[[1]]$x, ch$bdry[[1]]$y)

        indx <- apply (xymn, 1, function (x)
                   sp::point.in.polygon (x [1], x [2], bdry [,1], bdry [,2]))
        # indx = 0 for outside polygon
    } 

    # Then convert to integer indices into z
    xymn [,1] <- ceiling (grid_size * 
                          (xymn [,1] - map$coordinates$limits$x [1]) / 
                          diff (map$coordinates$limits$x))
    xymn [,2] <- ceiling (grid_size * 
                          (xymn [,2] - map$coordinates$limits$y [1]) / 
                          diff (map$coordinates$limits$y))
    if (missing (bg))
    {
        xymn [xymn < 1] <- 1
        xymn [xymn > grid_size] <- grid_size
    } else
    {
        xymn [xymn < 1] <- NA
        xymn [xymn > grid_size] <- NA
    }


    if ('polygons' %in% class (xy) | 'lines' %in% class (xy))
    {
        for (i in seq (xy))
            xy [[i]] <- cbind (i, xy [[i]], z [xymn [i, 1], xymn [i, 2]],
                               indx [i])
        # And rbind them to a single matrix. 
        xy <-  do.call (rbind, xy)
    } else # can only be points
    {
        indx2 <- (xymn [,2] - 1) * grid_size + xymn [,1]
        xy <- cbind (seq (dim (xy)[1]), xy, z [indx2], indx)
    }
    # And then to a data.frame, for which duplicated row names flag warnings
    # which are not relevant, so are suppressed by specifying new row names
    xy <-  data.frame (
                       id=xy [,1],
                       lon=xy [,2],
                       lat=xy [,3],
                       z=xy [,4], 
                       inp=xy [,5],
                       row.names=1:nrow (xy)
                       )
    return (xy)
}
